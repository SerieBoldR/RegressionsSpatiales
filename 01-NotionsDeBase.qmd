# Notions de base {#sec-chap01}

Dans ce chapitre, nous décrivons comment importer, manipuler et cartographier des données spatiales dans R. Pour une description plus détaillée du langage de programmation R -- objets et expression, opérateurs, structures de données (vecteurs, matrices, *arrays*, *DataFrame*), importation et manipulation de données --, lisez le chapitre intitulé [*Prise en main avec R*](https://serieboldr.github.io/MethodesQuantitatives/01-priseenmainR.html) [@RBoldAir].

::: bloc_package
::: bloc_package-header
::: bloc_package-icon
:::

**Liste des *packages* utilisés dans ce chapitre**
:::

::: bloc_package-body
-   Pour importer et manipuler des fichiers géographiques :
    -   `sf` pour importer et manipuler des données vectorielles.
-   Pour cartographier des données :
    -   `ggplot2` est un *package* pour construire des graphiques qui peut être aussi utilisé pour visualiser des données spatiales.
    -   `tmap` pour construire des cartes thématiques.
    -   `RColorBrewer` pour construire une palette de couleur.
    -   `ggpurb` pour combiner des graphiques et des cartes.
:::
:::


## Description des jeux de données utilisés dans le manuel {#sec-011}

## Conceptualisation de l'espace : matrices des pondérations spatiales {#sec-012}
### Matrices de contiguïté {#sec-0121}
### Matrices de proximité {#sec-0122}
### Standardisation des matrices de pondération spatiale en ligne {#sec-0123}
### Mise en œuvre dans R {#sec-0124}

## Notion de variable spatialement décalée {#sec-013}

## Notion d'autocorrélation spatiale {#sec-014}
### Autocorrélation spatiale globale {#sec-0141}
#### Statistique du *I* de Moran {#sec-01411}
#### Statistiques de comptage de jointure {#sec-01412}

### Autocorrélation spatiale locale {#sec-0142}
#### Statistiques locales de Getis et Ord {#sec-014121}
#### Typologie basée sur le diagramme de Moran {#sec-014122}
#### Version locale des statistiques de comptage de jointure {#sec-014123}


## Retour sur la régression linéaire multiple  {#sec-015}
## Notion de dépendance spatiale et d’hétérogénéité spatiale et de non-stationnarité spatiale  {#sec-016}

## Pourquoi recourir à des régressions spatiales?  {#sec-017}



<!-- ## Importation de données géographiques {#sec-011} -->

<!-- ::: bloc_notes -->
<!-- ::: bloc_notes-header -->
<!-- ::: bloc_notes-icon -->
<!-- ::: -->

<!-- **Quels *packages* choisir pour importer et manipuler des données spatiales?** -->
<!-- ::: -->

<!-- ::: bloc_notes-body -->
<!-- Pour les données vectorielles, il existe deux principaux *packages* (équivalent d'une librairie dans Python) : `sp` [@PackageSP1; @PackageSP2] et `sf` [@PackageSF]. Puisque le *package* `sp` est progressivement délaissé par R, il est donc fortement conseillé d'utiliser `sf`. -->

<!-- Pour les données *raster*, il est possible d'utiliser les *packages* `raster` [@PackageRaster] et `terra` [@PackageTerra], dont le dernier, plus récent, semblerait plus rapide. -->

<!-- Cette transition de `sp` à `sf` et de `raster` à `terra` est assez récente et encore en cours durant l'écriture de ce livre. Il existe encore de nombreux *packages* basés sur `sp` et `raster`. Il est donc possible que vous ayez à les utiliser, car leur transition n'est peut-être pas encore effectuée. Notez que la façon dont ces anciens *packages* intègrent les données vectorielles et matricielles dans R est très différente de celle des nouveaux *packages*. À titre d'exemple, la fonction `sp::readOGR` lit un fichier *shapefile*, tout comme la fonction `sf::st_read`, mais la première produit un objet de type `SpatialDataFrame`, alors que la seconde produit un `tbl_df`. Dans le premier cas, les géométries et les données sont stockées dans deux éléments séparés, alors que dans le second cas, le `tbl_df` est un `data.frame` avec une colonne contenant les géométries. -->

<!-- Pour les personnes intéressées aux motivations ayant conduit à cette transition, consultez cet excellent [article de blog](https://r-spatial.org/r/2022/04/12/evolution.html). Il existe deux raisons principales : le mainteneur des *packages* `rgdal` et `rgeos` servant de fondation à `raster` et `sp` a pris sa retraite. À cela s'ajoutent le côté « vieille école » de ces *packages* (ayant plus de 20 ans!) et l'apparition de *packages* plus modernes. Il s'agit d'un bon exemple de ce qui peut arriver dans une communauté *open source* et des évolutions constantes de l'environnement R. -->

<!-- En résumé, privilégiez l'utilisation de `sf` et de `terra.` -->

<!-- Il convient d'installer les deux *packages*. Notez que l'installation d'un *package* requiert une connexion Internet, car R accède au répertoire de *packages* *CRAN* pour télécharger le *package* et l'installer sur votre ordinateur. Cette opération est réalisée avec la fonction `install.packages("nom du package").` Notez qu'une fois que le *package* est installé, il est enregistré localement sur votre ordinateur et y reste à moins de le désinstaller avec la fonction `remove.packages("nom du package").` -->

<!-- Autrement dit, il n'est pas nécessaire de les installer à chaque ouverture de R! Pour utiliser les fonctions d'un *package*, vous devez préalablement le charger avec la fonction `library("Nom du package")` (équivalent à la fonction `import` de Python). -->

<!-- Pour plus d'informations sur l'installation et le chargement de *packages*, consultez la [section suivante](https://serieboldr.github.io/MethodesQuantitatives/01-priseenmainR.html#sec-0123) [@RBoldAir]. -->
<!-- ::: -->
<!-- ::: -->

<!-- ### Importation de données vectorielles {#sec-0111} -->

<!-- La fonction `st_read` de `sf` permet d'importer une multitude de formats de données géographiques, comme des fichiers *shapefile* (`shp`), *GeoPackage* (`GPKG`), *GeoJSON* (`geojson`), *sqlite* (`sqlite`), *geodatabase d'ESRI* (`FileGDB`), *Geoconcept* (`gxt`), *Keyhole Markup Language* (`kml`), *Geography Markup Language* (`gml`), etc. -->

<!-- #### Importation d'un fichier *shapefile* {#sec-01111} -->

<!-- Le code R ci-dessous permet d'importer des couches géographiques au format *shapefile*. Notez que la fonction `list.files(pattern = ".shp")` renvoie préalablement la liste des couches *shapefile* présentes dans le dossier de travail. -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| message: false -->
<!-- #| warning: false -->

<!-- ## Chargement des packages -->
<!-- library("sf") -->
<!-- library("terra") -->
<!-- library("tmap") -->
<!-- library("ggplot2") -->
<!-- library("ggpubr") -->
<!-- library("foreign") -->
<!-- library("xlsx") -->
<!-- library("rmapshaper") -->
<!-- library("RColorBrewer") -->
<!-- ## Obtention d'une liste des shapefiles dans le dossier de travail -->
<!-- list.files(path = "data/chap01/shp", pattern = ".shp") -->
<!-- ## Importation des shapefiles avec sf -->
<!-- Arrondissements <- st_read("data/chap01/shp/Arrondissements.shp", quiet=TRUE) -->
<!-- InstallationSport <- st_read("data/chap01/shp/Installations_sportives_et_recreatives.shp", quiet=TRUE) -->
<!-- PistesCyclables <- st_read("data/chap01/shp/Pistes_cyclables.shp", quiet=TRUE) -->
<!-- Rues <- st_read("data/chap01/shp/Segments_de_rue.shp", quiet=TRUE) -->
<!-- ``` -->

<!-- Regardons à présent la structure des couches importées. Pour ce faire, nous utilisons la fonction `head(nom du DataFrame, n=2)`; notez que le paramètre `n` permet de spécifier le nombre des premiers enregistrements à afficher. Les informations suivantes sont ainsi disponibles : -->

<!-- -   `6 fields` : six champs attributaires (`TYPE`, `DETAIL`, `NOM`, `SURFACE`, `ECLAIRAGE`, `OBJECTID`). -->

<!-- -   `Geometry type POINT` : le type de géométrie est **point**. -->

<!-- -   `Bounding box:  xmin: -8009681 ymin: 5686891 xmax: -8001939 ymax: 5696536` : les quatre coordonnées définissant l'enveloppe de la couche. -->

<!-- -   `Projected CRS: WGS 84 / Pseudo-Mercator` : la projection cartographique. Ici, une projection cartographique utilisée par Google Maps et OpenStreetMap. -->

<!-- -   La géométrie est enregistrée dans le champ `geometry`. Pour le premier enregistrement, nous avons la valeur `POINT (-8001939 5686891)`, soit un point avec les coordonnées géographiques (x,y) entre parenthèses. -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- head(InstallationSport, n=2)   # Visualisation des deux premiers enregistrements -->
<!-- names(InstallationSport)       # Noms de champs (colonnes) -->
<!-- View(InstallationSport)        # Afficher l'ensemble de la table attributaire -->
<!-- ``` -->

<!-- Explorons les types de géométries et la projection des autres couches avec le code ci-dessous. En résumé, les types de géométries sont : -->

<!-- -   Des géométries simples -->

<!--     -   `point` : un seul point. -->

<!--     -   `linestring` : une séquence de deux points et plus formant une ligne. -->

<!--     -   `polygon` : un seul polygone formé par une séquence de points pouvant contenir un ou plusieurs polygones intérieurs formant des trous. -->

<!-- -   Des géométries multiples -->

<!--     -   `multipoint` : plusieurs points pour une même observation. -->

<!--     -   `multilinestring` : plusieurs lignes pour une même observation. -->

<!--     -   `multipolygon` : plusieurs polygones pour une même observation. -->

<!-- -   Une collection de géométries (`Geometrycollection`) qui peut contenir différents types de géométries décrites ci-dessus pour une même observation. -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- head(PistesCyclables, n=2) -->
<!-- head(Rues, n=2) -->
<!-- head(Arrondissements, n=2) -->
<!-- ``` -->

<!-- Visualisons quelques couches importées avec `ggplot()`. -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- ## Arrondissements et rues -->
<!-- ggplot()+ geom_sf(data = Arrondissements, lwd = .8)+ -->
<!--   geom_sf(data = Rues, aes(colour = TYPESEGMEN)) -->
<!-- ## Arrondissements, pistes cyclables et installations sportives -->
<!-- ggplot()+ geom_sf(data = Arrondissements, lwd = .8)+ -->
<!--   geom_sf(data = PistesCyclables, aes(colour = NOM), lwd = .5)+ -->
<!--   geom_sf(data = InstallationSport) -->
<!-- ``` -->

<!-- #### Importation d'une couche dans un *GeoPackage* {#sec-01112} -->

<!-- Pour importer une couche stockée dans un *GeoPackage* (GPKG), vous devez spécifier le fichier et la couche avec respectivement les paramètres `dsn` et `layer` de la fonction `st_read`. Le code ci-dessous permet d'importer les secteurs de recensement de la région métropolitaine de recensement de Sherbrooke pour l'année 2021. Notez que la fonction `st_layers(dsn)` permet d'obtenir la liste des couches contenues dans le fichier GPKG, avec le type de géométrie, les nombre d'entités spatiales et de champs, et la projection cartographique pour chacune d'elles. -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- ## Nom du fichier GPKG -->
<!-- fichierGPKG <- "data/chap01/gpkg/Recen2021Sherbrooke.gpkg" -->
<!-- ## Liste des couches dans le GPKG -->
<!-- st_layers(dsn=fichierGPKG, do_count = TRUE) -->
<!-- ## Importation d'une couche -->
<!-- SR.RMRSherb <- st_read(dsn = fichierGPKG,  -->
<!--                        layer = "SherbSR", quiet=TRUE) -->
<!-- ## Affichage des deux premiers enregistrements -->
<!-- head(SR.RMRSherb, n=2) -->
<!-- ## Visualisation rapide des secteurs avec ggplot -->
<!-- ggplot()+ geom_sf(data = SR.RMRSherb, lwd = .5) -->
<!-- ``` -->

<!-- ## Manipulation de données vectorielles {#sec-012} -->

<!-- ::: bloc_objectif -->
<!-- ::: bloc_objectif-header -->
<!-- ::: bloc_objectif-icon -->
<!-- ::: -->

<!-- ***Package*** `sf` **et opérations géométriques** -->
<!-- ::: -->

<!-- ::: bloc_objectif-body -->
<!-- Le *package* `sf` est une librairie extrêmement complète permettant de réaliser une multitude d'opérations géométriques sur des couches vectorielles comme dans un système d'information géographique (SIG). Notre objectif n'est pas de toutes les décrire, mais d'aborder les principales. Au fil de vos projets avec `sf`, vous apprendrez d'autres fonctions. Pour ce faire, n'hésitez pas à consulter : -->

<!-- -   Une belle [*Cheatsheet*](https://github.com/rstudio/cheatsheets/blob/main/sf.pdf) sur `sf`. Allez y jeter un œil, cela vaut la peine! -->

<!-- -   Sur le [site CRAN](https://cran.r-project.org/web/packages/sf/index.html) de `sf`, vous trouverez plusieurs vignettes explicatives (exemples de code documentés). -->

<!-- -   La [documentation complète en PDF](https://cran.r-project.org/web/packages/sf/sf.pdf). -->

<!-- La syntaxe `methods(class = 'sfc')` renvoie la liste des méthodes implémentées dans le *package* `sf`. Pour accéder à l'aide en ligne de l'une d'entre elles, écrivez simplement `?Nom de la fonction` (ex. : `?st_buffer`). -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- methods(class = 'sfc') -->
<!-- ``` -->
<!-- ::: -->
<!-- ::: -->

<!-- ### Fonctions relatives à la projection cartographique {#sec-0121} -->

<!-- Les trois principales fonctions relatives à la projection cartographique des couches vectorielles sont : -->

<!-- -   `st_crs(x)` pour connaître la projection géographique d'un objet `sf`. -->

<!-- -   `st_transform(x, cr)` pour modifier la projection cartographique. -->

<!-- -   `st_is_longlat(x)` pour vérifier si les coordonnées sont en degrés longitude/latitude. -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- ## Importation d'un shapefile pour la province de Québec -->
<!-- ProvinceQc <- st_read("data/chap01/shp/Quebec.shp", quiet = TRUE) -->
<!-- ## La projection est EPSG:3347 - NAD83 / Statistics Canada Lambert, -->
<!-- ## soit la projection conique conforme de Lambert -->
<!-- st_crs(ProvinceQc) -->
<!-- ## Reprojection de la couche en WGS84 long/lat (EPSG:4326) -->
<!-- ProvinceQc.4326 <- st_transform(ProvinceQc, crs = 4326) -->
<!-- ## longitude/latitude? -->
<!-- st_is_longlat(ProvinceQc) -->
<!-- st_is_longlat(ProvinceQc.4326) -->
<!-- ``` -->

<!-- La @fig-Projections démontre bien que les deux couches sont projetées différemment. -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| label: fig-Projections -->
<!-- #| fig-cap: "Deux projections cartographiques" -->
<!-- #| out-width: 75% -->
<!-- #| fig-align: center -->

<!-- Map1 <- ggplot()+geom_sf(data = ProvinceQc)+coord_sf(crs = st_crs(ProvinceQc))+ -->
<!--         labs(subtitle = "Conique conforme de Lambert (EPSG : 3347)") -->

<!-- Map2 <- ggplot()+geom_sf(data = ProvinceQc.4326)+coord_sf(crs = st_crs(ProvinceQc.4326))+ -->
<!--         labs(subtitle = "WGS84 long/lat (EPSG : 4326)") -->

<!-- comp_plot <- ggarrange(Map1, Map2, ncol = 2, nrow = 1) -->
<!-- annotate_figure(comp_plot, -->
<!--                 top = text_grob("Province de Québec", -->
<!--                                 face = "bold", size = 12, just = "center") -->
<!--                 ) -->
<!-- ``` -->

<!-- ### Fonctions d'opérations géométriques sur une couche {#sec-0122} -->

<!-- Il existe une quinzaine de fonctions d'opérations géométriques sur une couche dans le *package* `sf` dont le résultat renvoie de nouvelles géométries ([voir la documentation suivante](https://r-spatial.github.io/sf/reference/geos_unary.html)). Nous décrivons ici uniquement celles qui nous semblent les plus utilisées : -->

<!-- -   `st_bbox(x)` renvoie les coordonnées minimales et maximales des géométries d'un objet `sf`. Pour créer l'enveloppe d'un objet `sf`, il suffit donc d'écrire `st_as_sfc(st_bbox(x))`. -->

<!-- -   `st_boundary(x)` renvoie les limites (contours) des géométries d'un objet `sf`. -->

<!-- -   `st_convex_hull(x)` crée l'enveloppe convexe des géométries d'un objet `sf`. -->

<!-- -   `st_combine(x)` regroupe les géométries d'un objet `sf` en une seule géométrie, sans les réunir ni résoudre les limites internes. -->

<!-- -   `st_union(x)` fusionne les géométries d'un objet `sf` en une seule géométrie. -->

<!-- -   `st_buffer(x, dist, endCapStyle = c("ROUND", "FLAT", "SQUARE"), joinStyle = c("ROUND", "MITRE", "BEVEL"))` crée des zones tampons d'une distance définie avec le paramètre `dist`. Cette fonction s'applique à des points, à des lignes et à des polygones. -->

<!-- -   `st_centroid(x)` crée des points au centre de chaque géométrie d'un objet `sf`. Elle s'applique donc à des lignes et à des polygones. -->

<!-- -   `st_point_on_surface(x)` crée un point au centre de chaque polygone d'un objet `sf` . -->

<!-- -   `st_simplify(x, dTolerance)` simplifie les contours de géométries (lignes ou polygones) avec une tolérance exprimée en mètres (paramètre `dTolerance`) d'un objet `sf` . -->

<!-- -   `st_voronoi(x, bOnlyEdges = TRUE)` crée des polygones de Thiessen, appelés aussi polygones de Voronoï pour des points. Attention, le paramètre `bOnlyEdges = TRUE` renvoie des lignes tandis que `bOnlyEdges = FALSE` renvoie des polygones. -->

<!-- #### Enveloppe et union d'une couche {#sec-01221} -->

<!-- Le code ci-dessous crée une enveloppe (en bleu) et un polygone fusionné (en rouge) pour les arrondissements de la ville de Sherbrooke (@fig-EnveloppeUnion). La couche résultante de l'opération `st_as_sfc(st_bbox(x))` est ainsi l'équivalent des outils `Emprise` de QGIS et `Minimum Bounding Geometry (Geometry Type = Envelope)` d'ArcGIS Pro. -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- ## Enveloppe sur les arrondissements de la ville de Sherbrooke -->
<!-- Arrond.Enveloppe <- st_as_sfc(st_bbox(Arrondissements)) -->
<!-- ## Fusionne les géométries en une seule en résolvant les limites internes -->
<!-- Arrond.Union <- st_union(Arrondissements) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| label: fig-EnveloppeUnion -->
<!-- #| fig-cap: "Enveloppe sur une couche" -->
<!-- #| fig-align: center -->
<!-- #| out-width: 65% -->

<!-- tmap_mode("plot") -->
<!-- tm_shape(Arrond.Enveloppe) + tm_borders(col = "blue", lwd=2)+ -->
<!--   tm_shape(Arrond.Union) + tm_borders(col = "red", lwd=2)+ -->
<!--   tm_layout(frame = FALSE)+ -->
<!--   tm_scale_bar(c(0,5,10)) -->
<!-- ``` -->

<!-- #### Centroïdes et centre de surface {#sec-01223} -->

<!-- Le code ci-dessous extrait les centres géométriques, c'est-à-dire les centroïdes (en bleu) et les points à l'intérieur des polygones (en rouge) pour les arrondissements de la ville de Sherbrooke (@fig-CentroidesPointsInterieur). Ces deux opérations correspondent aux outils `centroïdes` et `Point dans la surface` de QGIS et `Feature to Point (avec l'option Inside)` d'ArcGIS Pro. -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- ## Centroïdes et points dans les polygones sur les arrondissements -->
<!-- Arrond.centroide <- st_centroid(Arrondissements) -->
<!-- Arrond.pointpoly <- st_point_on_surface(Arrondissements) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #| echo: false -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| label: fig-CentroidesPointsInterieur -->
<!-- #| fig-cap: "Centroïdes et points à l'intérieur des polygones" -->
<!-- #| fig-align: center -->
<!-- #| out-width: 65% -->
<!-- tm_shape(Arrondissements) + tm_borders(col = "black", lwd=2)+ -->
<!-- tm_shape(Arrond.centroide) + tm_dots(size=0.3,col="blue")+ -->
<!-- tm_shape(Arrond.pointpoly) + tm_dots(size=0.3,col="red")+ -->
<!-- tm_layout(frame = FALSE) -->
<!-- ``` -->

<!-- ## Cartographie avec R {#sec-015} -->

<!-- ::: bloc_objectif -->
<!-- ::: bloc_objectif-header -->
<!-- ::: bloc_objectif-icon -->
<!-- ::: -->

<!-- **Pourquoi cartographier des données dans R?** -->
<!-- ::: -->

<!-- ::: bloc_objectif-body -->
<!-- Vous avez certainement un logiciel de SIG préféré pour construire une carte thématique (QGIS ou ArcGIS Pro par exemple). Puisqu'en quelques clics de souris, il est facile de réaliser une carte dans un SIG, quel est donc l'intérêt d'écrire des lignes de code pour afficher une carte dans R? Autrement dit, pourquoi devriez-vous vous compliquer la vie à apprendre de la syntaxe R pour produire une simple carte? Savoir cartographier dans R a plusieurs avantages : -->

<!-- -   Cartographier rapidement les résultats d'une analyse dans R permet d'éviter des allers-retours (exportation et importation de données) entre R et un logiciel de SIG. Or, la cartographie fait partie intégrante d'une démarche méthodologique d'analyse ou de modélisation spatiale. Vous restez ainsi dans le même environnement de travail (R) jusqu'à l'obtention de vos résultats finaux. Une fois ces derniers obtenus, vous pouvez les exporter et construire une carte très élaborée dans un logiciel de SIG. -->

<!-- -   La syntaxe R n'est pas si compliquée. Quelques lignes de code écrites pour une première analyse peuvent être réutilisées, modifiées et bonifiées pour une autre analyse. Au fil de vos projets, vous construirez des cartes de plus en plus élaborées. Autrement dit, après quelques heures d'investissement, vous deviendrez une personne experte en cartographie dans R! -->
<!-- ::: -->
<!-- ::: -->

<!-- ::: bloc_package -->
<!-- ::: bloc_package-header -->
<!-- ::: bloc_package-icon -->
<!-- ::: -->

<!-- **Quels *packages* utiliser pour la cartographie dans R?** -->
<!-- ::: -->

<!-- ::: bloc_package-body -->
<!-- Il existe plusieurs *packages* R pour la cartographie, notamment : -->

<!-- -   `ggplot2` est certainement le meilleur *package* R pour réaliser des graphiques [@ggplot2Package]. Il permet désormais de construire des cartes. -->

<!-- -   `cartography` permet de construire efficacement des cartes thématiques [@cartographyPackage]. Pour avoir une idée de son potentiel, consultez cette [*Cheatsheet*](http://riatelab.github.io/cartography/vignettes/cheatsheet/cartography_cheatsheet.pdf). -->

<!-- -   `tmap` [@tmapArticle] est actuellement l'un des *packages* les plus complets et les plus utilisés pour construire des cartes thématiques. -->

<!-- -   Des *packages* spécifiques permettent de créer des cartes interactives sur Internet, notamment `mapview`, `mapdeck` et `leaflet`. Ce dernier est basé sur la librairie JavaScript, largement utilisée dans le domaine de la cartographie sur Internet. -->

<!-- Dans cette section, nous utilisons uniquement `tmap` dont plusieurs ressources sont disponibles sur Internet : -->

<!-- -   Sur le [site CRAN de `tmap`](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html), une excellente vignette intitulée *tmap: get started!* -->

<!-- -   [Un article dans Journal of Statistical Software](https://doi.org/10.18637/jss.v084.i06) de Martijn Tennekes, créateur du *package* `tmap`. -->

<!-- -   La [documentation complète en PDF](https://cran.r-project.org/web/packages/tmap/tmap.pdf). -->
<!-- ::: -->
<!-- ::: -->

<!-- ### Manipulation des couches géométriques {#sec-0151} -->

<!-- #### Principales fonctions de représentation de couches vectorielles et matricielles {#sec-01511} -->

<!-- Il existe trois catégories de fonctions pour paramétrer l'affichage de couches géographiques (@tbl-TmapMiseGeometrie). -->

<!-- ```{r} -->
<!-- #| label: tbl-TmapMiseGeometrie -->
<!-- #| tbl-cap: Principales fonctions pour manipuler des couches vectorielles et matricielles -->
<!-- #| echo: false -->
<!-- #| warning: false -->
<!-- #| message: false -->

<!-- df1 <- data.frame( -->
<!--   Fonction = c("`tm_shape`", -->
<!--                "`tm_polygons`", "`tm_symbols`", "`tm_lines`", "`tm_text`", "`tm_raster`", -->
<!--                "`tm_fill`", "`tm_border`", "`tm_bubbles`", "`tm_squares`", "`tm_dots`", "`tm_markers`"), -->
<!--   Description = c("Crée un élément `tmap` à partir d'une couche géographique vectorielle (`sf`) ou matricielle (`raster`)", -->
<!--                   "Dessine des polygones (couleur et contour)",  -->
<!--                   "Dessine des symboles",  -->
<!--                   "Dessine des lignes",  -->
<!--                   "Dessine des étiquettes à partir d'un champ",  -->
<!--                   "Affiche un raster", -->
<!--                   "Dessine l'intérieur de polygones",  -->
<!--                   "Dessine les contours",  -->
<!--                   "Dessine des cercles (notamment proportionnels)",  -->
<!--                   "Dessine des carrés (notamment proportionnels)",  -->
<!--                   "Dessine des points",  -->
<!--                   "Dessine des icones avec étiquettes"), -->
<!--   Points  = c("X", -->
<!--               " ", "X", " ", "X", " ", -->
<!--               " ", " ", "X", "X", "X", "X"), -->
<!--   Lignes = c("X", -->
<!--              " ", "X", "X", "X", " ", -->
<!--              " ", " ", "X", "X", "X", "X"), -->
<!--   Polyg = c("X", -->
<!--              "X", "X", " ", "X", " ", -->
<!--              "X", "X", "X", "X", "X", "X"), -->
<!--   Raster = c("X",  -->
<!--              " ", " ", " ", " ", "X", -->
<!--              " ", " ", " ", " ", " ", " ")) -->

<!-- my_table <- knitr::kable(df1, -->
<!--             format.args = list(decimal.mark = ',', big.mark = " "), -->
<!-- 			col.names = c("Fonction","Description", "Points", "Lignes", "Polyg.", "Raster"), -->
<!--               align=c("l", "r", "c", "c", "c", "c")) -->

<!-- kableExtra::pack_rows(my_table, -->
<!--                       index = c("Fonction principale" = 1, -->
<!--                                  "Fonctions de base de manipulation" = 5, -->
<!--                                  "Autres fonctions de manipulation" = 6)) -->
<!-- ``` -->

<!-- **Construction d'une carte simple avec une couche vectorielle et une couche matricielle** -->

<!-- Le code ci-dessous permet d'afficher deux couches avec la fonction `tm_shape` : l'une vectorielle, l'autre matricielle (@fig-ArrondRaster1). -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| eval: false  -->
<!-- tmap_mode("plot") -->
<!-- # 1er objet tmap pour une couche raster -->
<!-- tm_shape(MosaicSherbCrop)+ -->
<!--   tm_raster(palette = terrain.colors(10))+ -->
<!-- # 1er objet tmap pour une couche vectorielle -->
<!-- tm_shape(Arrondissements)+ -->
<!--   tm_borders(col = "black", lwd = 3)+ # contour noir avec une épaisseur de trois points -->
<!--   tm_text("NUMERO") # Étiquettes identifiant l'arrondissement -->
<!-- ``` -->

<!-- ![Exemple de carte construite avec le *package* `tmap` avec une couche polygonale et une image](images/Chap01/Carte1.png){#fig-ArrondRaster1 width="50%" fig-align="center"} -->

<!-- ::: bloc_attention -->
<!-- ::: bloc_attention-header -->
<!-- ::: bloc_attention-icon -->
<!-- ::: -->

<!-- **Ordre et hiérarchie des couches avec `tmap`**. -->
<!-- ::: -->

<!-- ::: bloc_attention-body -->
<!-- Vous avez compris qu'une couche est affichée avec la fonction `tm_shape` et que le `+` permet d'ajouter une ou plusieurs fonctions d'habillage à cette couche (`tm_polygons`, `tm_lines`, `tm_text`, `tm_raster`, etc.). -->

<!-- Il est possible d'en superposer en utilisant plusieurs `tm_shape` comme suit : -->

<!-- `tm_shape(Nom de la première couche)+` `... paramètres de la couche +` `tm_shape(Nom de la seconde couche)+` `... paramètres de la couche` -->

<!-- Notez que la première couche est celle avec laquelle la projection et l'étendue de la carte sont définies. Il est toutefois possible de changer le tout en utilisant l'argument `is.master = TRUE` dans le `tm_shape` d'une couche donnée. -->
<!-- ::: -->
<!-- ::: -->

<!-- **Construction d'une carte avec plusieurs couches vectorielles** -->

<!-- Les lignes de code suivantes permettent de construire la @fig-fig2PolyPointsLignes avec trois couches `sf`. -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-fig2PolyPointsLignes -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Exemple de carte construite avec le *package* `tmap` avec plusieurs couches vectorielles (polygones, lignes, points)" -->
<!-- #| out-width: 85% -->
<!-- tmap_mode("plot") -->
<!-- ## Polygones -->
<!-- tm_shape(Arrondissements)+ -->
<!--   tm_text("NUMERO")+ # Étiquettes identifiant l'arrondissement -->
<!--   tm_polygons(col="wheat", border.col = "black", lwd = 3)+ -->
<!-- ## Lignes -->
<!-- tm_shape(Rues)+ -->
<!--   tm_lines(col= "gray", lwd = 1)+ -->
<!-- ## Points -->
<!-- tm_shape(PointsGPS.Sherb)+ -->
<!--   tm_dots(shape=21, col="blue", size=.3) -->
<!-- ``` -->

<!-- La @fig-fig3PointsEtMarkers illustre la différence entre les fonctions `tm_dots` et `tm_markers`. -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-fig3PointsEtMarkers -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Exemple de carte `tmap` avec `tm_dots` et `tm_markers`" -->
<!-- #| out-width: 85% -->

<!-- ## Points avec tm_dots() -->
<!-- CartePoints <-  -->
<!--   tm_shape(Arrondissements) + tm_polygons(col="wheat", border.col = "black") + -->
<!--   tm_shape(PointsGPS.Sherb) + tm_dots(shape=21, col="blue", size=.3) -->
<!-- ## Icones avec tm_markers() -->
<!-- CarteMarkers <-  -->
<!--   tm_shape(Arrondissements) + tm_polygons(col="wheat", border.col = "black") + -->
<!--   tm_shape(PointsGPS.Sherb) + tm_markers(size = 0.2, border.col = rgb(0,0,0,0)) -->
<!-- ## Combinaison des deux cartes -->
<!-- tmap_arrange(CartePoints, CarteMarkers, ncol=2, nrow=1) -->
<!-- ``` -->

<!-- #### Couleurs uniques et palette de couleurs dans `tmap` {#sec-01512} -->

<!-- Vous avez remarqué plus haut que plusieurs fonctions comprennent l'argument `col` pour spécifier une couleur. Pour connaître les trois manières de spécifier une couleur dans R -- nom de la couleur R (`lightblue` par exemple), code hexadécimal (`#f03b20` par exemple) ou notation RVBA (`rgb(0.2, 0.4, 0.4, 0)` par exemple) --, consultez [la section suivante](https://serieboldr.github.io/MethodesQuantitatives/03-magiedesgraphiques.html#sec-0315) [@RBoldAir]. -->

<!-- Pour spécifier une palette de couleurs sur un champ dans différentes fonctions (entre autres, `tm_polygons`, `tm_lines`, `tm_fill`, `tm_dots`), il suffit d'utiliser deux arguments dans la fonction, soit `col="Nom du champ"` et `palette="nom de la palette de couleurs"`. -->

<!-- Le *package* `tmap` intègre les palettes de deux autres *packages* : `viridisLite` [@viridisPackage] et `RColorBrewer` [@RColorBrewerPackage]. Le premier propose cinq palettes de couleurs : `viridis`, `magma`, `plasma`, `inferno`, `cividis`. Le second intègre une série de palettes de couleurs proposées par la géographe et cartographe Cynthia Brewer et ses collègues [@harrower2003colorbrewer; @brewer2003colorbrewer]. Vous avez probablement déjà exploré [leur site Internet](https://colorbrewer2.org/) où il est possible de sélectionner une palette en fonction du nombre de classes, de la nature des données et de la codification des couleurs (HEX, RGB, CMYK). Succinctement, `RColorBrewer` propose plusieurs palettes regroupées selon trois catégories : -->

<!-- -   Palettes qualitatives à appliquer à une variable qualitative nominale comme son nom l'indique (@fig-ColorBrewerQual). Pour afficher les palettes et connaître leurs noms, tapez `display.brewer.all(type="qual")` dans la console. -->

<!-- -   Palettes séquentielles pour une variable continue avec des valeurs faibles à fortes (@fig-ColorBrewerSeq). Tapez `display.brewer.all(type="seq")` dans la console. -->

<!-- -   Palettes divergentes à appliquer à une variable continue dont les valeurs aux deux extrémités s'opposent (@fig-ColorBrewerDiv). Tapez `display.brewer.all(type="div")` dans la console. -->

<!-- ![Palettes de couleurs qualitatives du *package* `RColorBrewer`](images/Chap01/RcolorBrewerQual.png){#fig-ColorBrewerQual width="40%" fig-align="center"} -->

<!-- ![Palettes de couleurs séquentielles du *package* `RColorBrewer`](images/Chap01/RcolorBrewerSeq.png){#fig-ColorBrewerSeq width="40%" fig-align="center"} -->

<!-- ![Palettes de couleurs divergentes du *package* `RColorBrewer`](images/Chap01/RcolorBrewerDiv.png){#fig-ColorBrewerDiv width="40%" fig-align="center"} -->

<!-- ::: bloc_astuce -->
<!-- ::: bloc_astuce-header -->
<!-- ::: bloc_astuce-icon -->
<!-- ::: -->

<!-- **Comparaison de palettes avec un nombre de classes défini** -->
<!-- ::: -->

<!-- ::: bloc_astuce-body -->
<!-- Si vous connaissez le nombre de classes, mais que vous hésitez à choisir telle ou telle palette de couleurs, tapez dans la console : -->

<!-- -   `display.brewer.all(n=5, type="seq", exact.n=TRUE)` -->
<!-- -   `display.brewer.all(n=5, type="div", exact.n=TRUE)` -->
<!-- -   `display.brewer.all(n=5, type="qual", exact.n=TRUE)` -->

<!-- D'autres arguments peuvent être ajoutés comme `colorblindFriendly=TRUE` qui renvoie uniquement des palettes de couleurs adaptées aux personnes daltoniennes. En guise d'exemple, avec cinq classes, il est possible de comparer neuf palettes divergentes et six autres adaptées aux personnes daltoniennes (@fig-RcolorBrewerAstuce). -->

<!-- ![Palettes de couleurs divergentes du *package* `RColorBrewer` avec cinq classes](images/Chap01/RcolorBrewerAstuce.png){#fig-RcolorBrewerAstuce width="60%" fig-align="center"} -->

<!-- Vous hésitez encore à choisir une palette de couleurs? Tapez la syntaxe ci-dessous dans la console pour afficher l'ensemble des palettes des *packages* `RColorBrewer` et `viridisLite`. -->

<!-- `tmaptools::palette_explorer()` -->

<!-- Pour inverser les couleurs d'une palette, vous devez précéder le nom de la palette par un signe moins (exemple : `-Greens`). -->
<!-- ::: -->
<!-- ::: -->

<!-- #### Cartographie d'une variable qualitative : valeurs uniques {#sec-01513} -->

<!-- **Application à une couche de points** -->

<!-- Le code ci-dessous illustre comment construire une carte thématique avec des couleurs appliquées à une variable qualitative nominale (champ `TYPE` de la couche `InstallationSport`) d'une couche de points (@fig-CarteVarQualPoints). -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-CarteVarQualPoints -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Exemple de cartographie d'une variable qualitative sur des points" -->
<!-- #| out-width: 85% -->
<!-- ## Carte -->
<!-- tm_shape(Arrondissements)+ -->
<!--   tm_borders()+ -->
<!-- tm_shape(InstallationSport)+ -->
<!--   tm_dots(shape = 21, -->
<!--           size=.3, -->
<!--           col= "TYPE",  -->
<!--           palette = "Set1",  -->
<!--           title ="Type d'installation")+ -->
<!-- tm_layout(main.title = "Installations sportives", -->
<!--           frame=FALSE, -->
<!--           legend.position = c("left", "top"), -->
<!--           legend.outside=TRUE) -->
<!-- ``` -->

<!-- **Application à une couche de lignes** -->

<!-- Le code ci-dessous illustre comment construire une carte thématique avec des couleurs appliquées à une variable qualitative nominale (champ `TYPESEGMEN`) d'une couche de lignes (@fig-CarteVarQualLignes). -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-CarteVarQualLignes -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Exemple de cartographie d'une variable qualitative sur des lignes" -->
<!-- #| out-width: 85% -->
<!-- ## Listes des valeurs uniques -->
<!-- table(Rues$TYPESEGMEN) -->
<!-- ## Lignes -->
<!-- tmap_mode("plot") -->
<!-- tm_shape(Rues)+ -->
<!--   tm_lines(col= "TYPESEGMEN", -->
<!--            palette = c("red", "brown4", "cornsilk1", "lightpink", "gainsboro"), -->
<!--            lwd = 2  -->
<!--            ) -->
<!-- ``` -->

<!-- **Application à une couche de polygones** -->

<!-- Le code ci-dessous illustre comment construire une carte thématique avec des couleurs appliquées à une variable qualitative nominale (champ `SDRNOM` de la couche `AD2021`) d'une couche de polygones (@fig-CarteVarQualPoly). -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-CarteVarQualPoly -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Exemple de cartographie d'une variable qualitative sur des polygones" -->
<!-- #| out-width: 85% -->

<!-- ## Importation de la couche des aires de diffusion de 2021 pour la RMR de Sherbrooke -->
<!-- AD2021 <- st_read(dsn = "data/chap01/gpkg/Recen2021Sherbrooke.gpkg",  -->
<!--                   layer = "SherbAD",  -->
<!--                   quiet = TRUE) -->
<!-- ## Carte -->
<!-- tmap_mode("plot") -->
<!-- tm_shape(AD2021)+ -->
<!--   tm_fill(col= "SDRNOM",  -->
<!--           palette = "Set2",  -->
<!--           lwd = 1,  -->
<!--           title ="Municipalité")+ -->
<!--   tm_borders(col="black")+ -->
<!-- tm_layout(main.title = "Aires de diffusion de 2021", -->
<!--           frame =FALSE, -->
<!--           legend.position = c("left", "top"), -->
<!--           legend.outside=TRUE) -->
<!-- ``` -->

<!-- #### Cartographie d'une variable discrète : cercles proportionnels {#sec-01514} -->

<!-- La syntaxe ci-dessous permet de créer une carte avec des cercles proportionnels pour les municipalités de la région administrative de l'Estrie (@fig-CarteCerclesProport). -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-CarteCerclesProport -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Exemple de carte avec des cercles proportionnels" -->
<!-- #| out-width: 85% -->

<!-- ## Importation des municipalités (subdivisions de recensements - SDR) de l'Estrie -->
<!-- SDR.Estrie <- st_read(dsn = "data/chap01/gpkg/Recen2021Sherbrooke.gpkg",  -->
<!--                   layer = "sdr_Estrie", quiet = TRUE) -->
<!-- ## Importation des MRC (divisions de recensements - DR) de l'Estrie -->
<!-- DR.Estrie <- st_read(dsn = "data/chap01/gpkg/Recen2021Sherbrooke.gpkg",  -->
<!--                   layer = "DREstrie2021",  quiet = TRUE) -->
<!-- ## Importation des données sur la population -->
<!-- PopSDR <- read.csv("data/chap01/tables/SDR_Estrie.csv") -->
<!-- PopSDR$SDRidu <- as.character(PopSDR$SDRidu) -->
<!-- ## Fusion des données -->
<!-- SDR.Estrie <- merge(SDR.Estrie, PopSDR, by.x = "SDRIDU", by.y = "SDRidu") -->
<!-- ## Construction de la carte -->
<!-- tmap_mode("plot") -->
<!-- tm_shape(SDR.Estrie)+ -->
<!--   tm_polygons(col="whitesmoke", border.col = "grey30", lwd = 1)+ -->
<!--   tm_bubbles(size = "SDRpop_2021", -->
<!--              border.col = "black", -->
<!--              col = "tomato1", -->
<!--              title.size = "Population", -->
<!--              scale = 3)+ # facteur multiplicateur pour la taille du cercle -->
<!-- tm_shape(DR.Estrie)+ -->
<!--   tm_borders(col="black", lwd = 2) -->
<!-- ``` -->

<!-- #### Cartographie d'une variable continue : cartes choroplèthes et méthodes de discrétisation {#sec-01515} -->

<!-- L'argument `style`, qui est commun à plusieurs fonctions (`tm_polygons`, `tm_fill`, `tm_lines`, `tm_dots`, etc.), permet de choisir une méthode de discrétisation dont les principales sont : -->

<!-- -   `fixed`: intervalles fixés par l'analyste. -->

<!-- -   `equal`: intervalles égaux. -->

<!-- -   `pretty`: intervalles arrondis aux nombres entiers. -->

<!-- -   `quantile`: selon les quantiles (même nombre d'observations dans chaque classe). -->

<!-- -   `jenks`: selon la méthode de Jenks. -->

<!-- -   `sd`: selon l'écart-type. -->

<!-- D'autres méthodes peuvent être utilisées comme `kmeans`, `hclust`, `bclust`, `fisher`, `dpih`, `headtails` et `log10_pretty.` En guise d'exemple, la @fig-CarteChropolete2 présente une discrétisation en cinq classes selon la méthode des quantiles. Notez aussi qu'il est possible de réaliser une carte avec un dégradé continu avec `style = "cont"` tel qu'illustré ci-dessous (@fig-CarteChropolete1). -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-CarteChropolete1 -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Exemple de carte choroplèthe avec une palette continue" -->
<!-- #| out-width: 85% -->

<!-- ## Sélection des aires de diffusion de Sherbrooke -->
<!-- AD2021.sherb <- subset(AD2021, SDRNOM == "Sherbrooke") -->
<!-- ## Carte -->
<!-- tmap_mode("plot") -->
<!-- tm_shape(AD2021.sherb)+ -->
<!--   tm_fill(col= "HabKm2",  -->
<!--           palette = "Reds",   -->
<!--           style = "cont", -->
<!--           title ="Hab./km2")+ -->
<!--   tm_borders(col="black") -->
<!-- ``` -->

<!-- La @fig-CarteChropolete2 utilise une discrétisation selon la méthode de quantiles avec cinq classes. Autrement dit, chaque classe comprend 20 % des aires de diffusion de la ville de Sherbrooke. -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-CarteChropolete2 -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Exemple de carte choroplèthe avec une discrétisation selon les quantiles" -->
<!-- #| out-width: 85% -->

<!-- tmap_mode("plot") -->
<!-- tm_shape(AD2021.sherb)+ -->
<!--   tm_fill(col= "HabKm2", -->
<!--           palette = "Reds",   -->
<!--           n = 5, # nombre de classes -->
<!--           style = "quantile", -->
<!-- 		  legend.format = list(text.separator = "à"), -->
<!--           title ="Hab./km2")+ -->
<!--   tm_borders(col="black", lwd = .5) -->
<!-- ``` -->

<!-- La @fig-MethoDiscretisation présente quatre méthodes de discrétisation différentes appliquées au revenu médian des ménages par secteur de recensement dans la région métropolitaine de recensement de Sherbrooke en 2021. -->

<!-- ![Différentes méthodes de discrétisation](images/Chap01/MethodesDiscretisation.png){#fig-MethoDiscretisation width="75%" fig-align="center"} -->

<!-- #### Combinaison de plusieurs cartes {#sec-01531} -->

<!-- Tel que décrit dans le @tbl-TmapMiseEnMap, il existe deux fonctions pour combiner deux cartes : `tmap_arrange` et `tm_facets`. -->

<!-- Pour ceux et celles réalisant régulièrement des graphiques dans R avec `ggplot2`, `tmap_arrange` est très similaire à la fonction `ggarrange` du *package* `ggpubr` qui permet de fusionner plusieurs graphiques. Globalement, le principe est le suivant : vous réalisez deux cartes ou plus que vous combinez dans une même sortie avec `tmap_arrange`. Vous trouverez ci-dessous un exemple avec deux cartes (@fig-CombinaisonAvecTmapArrange). -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-CombinaisonAvecTmapArrange -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Exemple de combinaisons de carte avec `tmap_arrange`" -->
<!-- #| out-width: 85% -->

<!-- tmap_mode("plot") -->
<!-- ## Carte 1 -->
<!-- Carte1 =  tm_shape(SDR.Estrie)+ -->
<!--             tm_polygons(col="whitesmoke", border.col = "grey30", lwd = 1)+ -->
<!--             tm_bubbles(size = "SDRpop_2021", -->
<!--                        border.col = "black", -->
<!--                        col = "tomato1", -->
<!--                        title.size = "Population", -->
<!--                        scale = 3)+ # facteur multiplicateur pour la taille du cercle -->
<!--           tm_shape(DR.Estrie)+ tm_borders(col="black", lwd = 2) -->
<!-- ## Calcul de la densité de population -->
<!-- SDR.Estrie$HabKm2 <- as.numeric(SDR.Estrie$SDRpop_2021 / (st_area(SDR.Estrie) / 1000000)) -->
<!-- ## Carte 2 -->
<!-- Carte2 =  tm_shape(SDR.Estrie)+ -->
<!--               tm_fill(col= "HabKm2",  -->
<!--                     palette = "Reds",   -->
<!--                     style = "quantile", n = 4, -->
<!--                     title ="Hab./km2", -->
<!--                     legend.format = list(text.separator = "à"))+ -->
<!--               tm_borders(col="black")+ -->
<!--           tm_shape(DR.Estrie)+ tm_borders(col="black", lwd = 2) -->
<!-- ## Combinaison des deux cartes -->
<!-- tmap_arrange(Carte1, Carte2, ncol = 2, nrow = 1) -->
<!-- ``` -->

<!-- Quant à la fonction `tm_facets`, elle permet de créer plusieurs cartes avec l'argument `by`. Prenons un exemple concret : vous disposez d'une couche géographique des municipalités du Québec et vous souhaitez réaliser une carte pour chaque région administrative. L'argument `by = "Region"` vous permet alors d'avoir une vignette par région. Dans l'exemple ci-dessous, nous avons cartographié la même variable (densité de population) pour différentes zones de la région métropolitaine de Sherbrooke (@fig-CombinaisonAvecFacets1). -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-CombinaisonAvecFacets1 -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Premier exemple de combinaison de cartes avec `tm_facets`" -->
<!-- #| out-width: 85% -->
<!-- tmap_mode("plot") -->
<!-- ## Création d'une variable zone basée sur les noms des municipalités -->
<!-- AD2021$Zone <- ifelse(AD2021$SDRNOM == "Sherbrooke", "A. Sherbrooke", "")  -->
<!-- AD2021$Zone <- ifelse(AD2021$SDRNOM %in% c("Compton", "Waterville", "Hatley", "North Hatley"),  -->
<!--                       "B. Sud", AD2021$Zone)  -->
<!-- AD2021$Zone <- ifelse(AD2021$SDRNOM %in% c("Orford", "Magog", "Saint-Denis-de-Brompton"),  -->
<!--                       "C. Est", AD2021$Zone)  -->
<!-- AD2021$Zone <- ifelse(AD2021$SDRNOM %in% c("Ascot Corner", "Val-Joli", "Stoke"),  -->
<!--                       "C. Nord", AD2021$Zone)  -->
<!-- ## Création des cartes avec tm_facets -->
<!-- tmap_mode("plot") -->
<!-- tm_shape(AD2021)+ -->
<!--   tm_fill(col= "HabKm2", -->
<!--           palette = "Reds",   -->
<!--           n = 5, # nombre de classes -->
<!--           style = "quantile", -->
<!--           title ="Hab./km2", -->
<!--           legend.format = list(text.separator = "à"))+ -->
<!--   tm_borders(col="black", lwd = .5)+ -->
<!--   tm_facets(by = "Zone") -->
<!-- ``` -->

<!-- L'utilisation de `tm_facets` peut être également très utile pour comparer les distributions spatiales de points à différentes années (@fig-CombinaisonAvecFacets2). -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-CombinaisonAvecFacets2 -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Deuxième exemple de combinaisons de carte avec `tm_facets`" -->
<!-- #| out-width: 85% -->
<!-- tmap_mode("plot") -->
<!-- ## Importation des incidents -->
<!-- Incidents <- st_read("data/chap01/shp/IncidentsSecuritePublique.shp", quiet = TRUE) -->
<!-- ## Création des cartes avec tm_facets -->
<!-- tmap_mode("plot") -->
<!-- tm_shape(Arrondissements) +  -->
<!--   tm_polygons(col="wheat", border.col = "black") + -->
<!-- tm_shape(Incidents) + -->
<!--   tm_dots(shape=21, col="blue", size=.2) + -->
<!-- tm_facets(by = "ANNEE") -->
<!-- ``` -->

<!-- #### Mise en page d'une carte {#sec-01532} -->

<!-- Nous reprenons la @fig-HabillageDuneCarte et l'habillons en ajoutant une échelle (`tm_scale_bar`), une flèche du Nord (`tm_compass`), la source et l'auteur (`tm_credits`) et un titre (`tm_layout`) (@fig-HabillageDuneCarte). -->

<!-- ```{r} -->
<!-- #| echo: true  -->
<!-- #| message: false  -->
<!-- #| warning: false -->
<!-- #| label: fig-HabillageDuneCarte -->
<!-- #| fig-align: center -->
<!-- #| fig-cap: "Habillage d'une carte" -->
<!-- #| out-width: 85% -->
<!-- ## Carte 1 -->
<!-- tmap_mode("plot") -->
<!-- tm_shape(SDR.Estrie)+ -->
<!--             tm_fill(col= "HabKm2", palette = "Greens",   -->
<!--                     style = "quantile", n = 4, -->
<!--                     title ="Hab./km2", -->
<!--                     legend.format = list(text.separator = "à"))+ -->
<!--             tm_bubbles(size = "SDRpop_2021", border.col = "black", col = "tomato1", scale = 3, -->
<!--                        title.size = "Population")+  -->
<!--             tm_borders(col="black")+ -->
<!-- ## Ajout de de la flèche du Nord -->
<!-- tm_compass(position = c("right", "bottom"),  -->
<!--            size = 2)+ -->
<!-- ## Ajout de l'échelle -->
<!-- tm_scale_bar(breaks  = c(0, 25, 50), -->
<!--              position = c("right", "bottom"))+ -->
<!-- ## Ajout de la source -->
<!-- tm_credits("Source : recensement de 2021, Statistique Canada\nAuteur : Jéremy Lacartemplace.",  -->
<!--            position = c("right", "bottom"), -->
<!--            size = 0.7, -->
<!--            align = "right") + -->
<!-- ## Légende   -->
<!-- tm_legend(position = c("left", "top"),  -->
<!--           frame = FALSE, bg.color = "white")+ -->
<!-- ## Modification de la mise en page -->
<!-- tm_layout(main.title = "Municipalités de l'Estrie", -->
<!--           legend.outside = TRUE, -->
<!--           frame = FALSE) -->
<!-- ``` -->

<!-- ::: bloc_aller_loin -->
<!-- ::: bloc_aller_loin-header -->
<!-- ::: bloc_aller_loin-icon -->
<!-- ::: -->

<!-- **Aller plus loin avec `tmap`?** -->
<!-- ::: -->

<!-- ::: bloc_aller_loin-body -->
<!-- Nous avons abordé uniquement les principales fonctions et arguments pour l'habillage d'une carte. Plusieurs exemples de très belles cartes créées avec `tmap` sont disponibles aux ressources suivantes : -->

<!-- -   L'excellente vignette intitulée [*`tmap`: get started!*](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) -->

<!-- -   [*Visualizing Spatial Data in R with tmap*](http://www.wvview.org/os_sa/10_Maps_with_tmap.html#visualizing-spatial-data-in-r-with-tmap). -->

<!-- -   [*Making Maps with R*](https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html). -->

<!-- -   Le chapitre [*Making maps with R*](https://geocompr.robinlovelace.net/adv-map.html) du livre [*Geocomputation with R*](https://geocompr.robinlovelace.net/index.html). -->
<!-- ::: -->
<!-- ::: -->
<!-- ## Quiz de révision du chapitre {#sec-016} -->

<!-- ```{r} -->
<!-- #| label: quizChapitre01 -->
<!-- #| echo: false  -->
<!-- #| eval: true  -->
<!-- #| message: false  -->
<!-- #| warning: false  -->
<!-- #| results: asis -->

<!-- source("code_complementaire/QuizzFunctions.R") -->
<!-- Chap01Quiz <- quizz("quiz/Chap01.yml", "Chap01") -->
<!-- render_quizz(Chap01Quiz) -->
<!-- ``` -->

<!-- ## Exercices de révision {#sec-017} -->

<!-- ::: bloc_exercice -->
<!-- ::: bloc_exercice-header -->
<!-- ::: bloc_exercice-icon -->
<!-- ::: -->

<!-- **Exercice 1.** Découpage des rues de l'arrondissement des Nations de la ville de Sherbrooke -->
<!-- ::: -->

<!-- ::: bloc_exercice-body -->
<!-- Complétez le code ci-dessous avec les étapes suivantes : -->

<!-- -   Requête attributaire pour créer un objet `sf` avec uniquement l'arrondissement des Nations à partir de la couche `Arrondissements` et le champ `NOM` (voir la [section @sec-01274]). -->

<!-- -   Découpez les rues (`Rues`) sur le nouvel objet `sf` (voir la [section @sec-01213]). -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| eval: false -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- library(sf) -->
<!-- ## Importation des deux couches -->
<!-- Arrond <- st_read("data/chap01/shp/Arrondissements.shp", quiet = TRUE) -->
<!-- Rues <- st_read("data/chap01/shp/Segments_de_rue.shp", quiet = TRUE) -->
<!-- ## Requête attributaire : création d'un objet sf pour l'arrondissement des Nations -->
<!-- table(Arrond$NOM) -->
<!-- Arrond.DesNations <- subset(À compléter) -->
<!-- ## Découper les rues avec le polygone de l'arrondissement des Nations -->
<!-- Rues.DesNations <- À compléter -->
<!-- ``` -->

<!-- Correction à la [section @sec-12011]. -->
<!-- ::: -->
<!-- ::: -->

<!-- ::: bloc_exercice -->
<!-- ::: bloc_exercice-header -->
<!-- ::: bloc_exercice-icon -->
<!-- ::: -->

<!-- **Exercice 2.** Calcul d'un nouveau champ -->
<!-- ::: -->

<!-- ::: bloc_exercice-body -->
<!-- Calculez un nouveau champ (`DistHVKM`) dans la couche des aires de diffusion (AD) (`AD.RMRSherb`) qui représente la distance en kilomètres entre l'hôtel de ville de Sherbrooke et les points des AD. Puis, cartographiez le champ `DistHVKM` en quatre classes selon la méthode de discrétisation par quantiles. Complétez le code ci-dessous avec les étapes suivantes : -->

<!-- -   Ajoutez un champ pour la distance (`DistHVKM`) dans la couche `AD.RMRSherb` (voir la [section @sec-0124]). -->

<!-- -   Cartographiez le champ `DistHVKM` en quatre classes selon la méthode des quantiles (voir la [section @sec-01515]). -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| eval: false -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- library(sf) -->
<!-- library(tmap) -->
<!-- ## Importation des deux couches -->
<!-- AD.RMRSherb <- st_read(dsn = "data/chap01/gpkg/Recen2021Sherbrooke.gpkg",  -->
<!--                        layer = "SherbAD", quiet = TRUE) -->
<!-- HotelVille <- data.frame(ID = 1, Nom = "Hôtel de ville", -->
<!--                          lon = -71.89306, lat = 45.40417) -->
<!-- HotelVille <- st_as_sf(HotelVille, coords = c("lon","lat"), crs = 4326) -->
<!-- ## Changement de projection avant de s'assurer que les deux couches ont la même -->
<!-- HotelVille <- st_transform(HotelVille, st_crs(AD.RMRSherb)) -->
<!-- ## Ajout d'un champ pour la distance en km à l'hôtel de ville pour les secteurs de recensement -->
<!-- AD.RMRSherb$DistHVKM <- À compléter -->
<!-- ## Cartographie en quatre classes selon les quantiles -->
<!-- tmap_mode("plot") -->
<!-- tm_shape(À compléter)+ -->
<!--   tm_fill(À compléter)+ -->
<!--   tm_borders(col="black") -->
<!-- ``` -->

<!-- Correction à la [section @sec-12012]. -->
<!-- ::: -->
<!-- ::: -->

<!-- ::: bloc_exercice -->
<!-- ::: bloc_exercice-header -->
<!-- ::: bloc_exercice-icon -->
<!-- ::: -->

<!-- **Exercice 3.** Importation d'une couche *shapefile* -->
<!-- ::: -->

<!-- ::: bloc_exercice-body -->
<!-- Importez une couche *shapefile* pour les divisions de recensement et calculez la densité de population (nombre d'habitants au km^2^). Complétez le code ci-dessous avec les étapes suivantes : -->

<!-- -   Faites une jointure attributaire entre la couche `DR.Qc` et la table `DR.Data` (voir la [section @sec-01272]). -->

<!-- -   Calculez le champ `HabKm2`, soit la division entre les champs `DRpop_2021` et `SUPTERRE` (voir la [section @sec-01515]). -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| eval: false -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- library(sf) -->
<!-- ## Importation de la couche des divisions de recensement du Québec -->
<!-- DR.Qc <- st_read(dsn = "data/chap01/gpkg/Recen2021Sherbrooke.gpkg",  -->
<!--                  layer = "DivisionsRecens2021", quiet = TRUE) -->
<!-- ## Importation du fichier csv des divisions de recensement -->
<!-- DR.Data <- read.csv("data/chap01/tables/DRQC2021.csv") -->
<!-- ## Jointure attributaire avec le champ IDUGD -->
<!-- DR.Qc <- A compléter -->
<!-- ## Il y a déjà deux champs dans la table pour calculer la densité de population : -->
<!-- ## SUPTERRE : superficie en km2 -->
<!-- ## DRpop_2021 : population en 2021 -->
<!-- DR.Qc$HabKm2 <- A compléter -->
<!-- head(DR.Qc, n=2) -->
<!-- summary(DR.Qc$HabKm2) -->
<!-- ``` -->

<!-- Correction à la [section @sec-12013]. -->
<!-- ::: -->
<!-- ::: -->

<!-- ::: bloc_exercice -->
<!-- ::: bloc_exercice-header -->
<!-- ::: bloc_exercice-icon -->
<!-- ::: -->

<!-- **Exercice 4.** Coordonnées géographiques -->
<!-- ::: -->

<!-- ::: bloc_exercice-body -->
<!-- Vous recevez les coordonnées en degrés (WGS84, EPSG : 4326) : -71.91688, 45.37579. Créez un point pour cette localisation et calculez la distance la séparant du tronçon autoroutier le plus proche. Complétez le code ci-dessous avec les étapes suivantes : -->

<!-- -   Faites une requête attributaire pour créer un objet `sf` avec uniquement les tronçons autoroutiers à partir de la couche `Rues` et le champ `TYPESEGMEN` (voir la [section @sec-01274]). -->

<!-- -   Trouvez l'identifiant du tronçon le plus proche avec la fonction `st_nearest_feature` (voir la [section @sec-0126]). -->

<!-- ```{r} -->
<!-- #| echo: true -->
<!-- #| eval: false -->
<!-- #| message: false -->
<!-- #| warning: false -->

<!-- library(sf) -->
<!-- ## Importation du réseau de rues -->
<!-- Rues <- st_read("data/chap01/shp/Segments_de_rue.shp", quiet=TRUE) -->
<!-- unique(Rues$TYPESEGMEN) -->
<!-- ## Sélection des tronçons autoroutiers -->
<!-- Autoroutes <- À compléter -->
<!-- ## Création d'une couche sf pour le point avec les coordonnées -->
<!-- ## en degrés (WGS84, EPSG : 4326) : -71.91688, 45.37579 -->
<!-- Point1_sf <- À compléter -->
<!-- ## Changement de projection avant de s'assurer que les deux couches ont la même -->
<!-- Point1_sf <- st_transform(Point1_sf, st_crs(Autoroutes)) -->
<!-- ## Trouver le tronçon autoroutier le plus proche avec la fonction st_nearest_feature -->
<!-- PlusProche <- À compléter -->
<!-- print(PlusProche) -->
<!-- Point1_sf$AutoroutePlusProche <- as.numeric(st_distance(Point1_sf, -->
<!--                                                         Autoroutes[PlusProche,])) -->
<!-- cat("Distance à l'autoroute la plus proche :", Point1_sf$AutoroutePlusProche, "m.") -->
<!-- ## Zone tampon -->
<!-- ZoneTampon <- st_buffer(Point1_sf, Point1_sf$AutoroutePlusProche) -->
<!-- ## Cartographie -->
<!-- tmap_mode("view") -->
<!-- tm_shape(ZoneTampon)+ -->
<!--   tm_borders(col= "black")+ -->
<!-- tm_shape(Autoroutes)+ -->
<!--   tm_lines(col="red")+ -->
<!-- tm_shape(Point1_sf)+ -->
<!--   tm_dots(col= "blue", shape=21, size = .2) -->
<!-- ``` -->

<!-- Correction à la [section @sec-12014]. -->
<!-- ::: -->
<!-- ::: -->
